import {  Dispatch,  FC,  PropsWithChildren,  SetStateAction,  createContext,  useCallback,  useContext,  useEffect,  useState,} from 'react';import { useParams } from 'react-router-dom';import { mockTesting } from '../../mock/mockTesting';import { TAnswer, TTesting } from '../../types/tests';export type TStageStatus = {  id: string;  status: 'wait' | 'process' | 'finish' | 'error';};type TPassContext = {  testLoaded: boolean;  testPending: boolean;  testLoadError: boolean;  test?: TTesting;  testIdToLoad?: string;  currentStage?: string;  setCurrentStage: (stage?: string) => void;  nextStage: () => void;  complete: () => void;  testAnswers: TAnswer[];  addAnswer: (answer: TAnswer | TAnswer[]) => void;  editAnswer: (answer: TAnswer) => void;  onTestStart: () => void;  testingStarted: boolean;  testStartedDate?: string;  stageStatuses: TStageStatus[];  setStageStatuses: Dispatch<SetStateAction<TStageStatus[]>>;  stageComplete: Record<    string,    {      questionsComplete: boolean;      descriptionComplete: boolean;    }  >;  setStageQuestionsComplete: Dispatch<    SetStateAction<      Record<        string,        {          questionsComplete: boolean;          descriptionComplete: boolean;        }      >    >  >;};const initialValues: TPassContext = {  testLoaded: true,  testPending: false,  testLoadError: false,  test: mockTesting,  testIdToLoad: undefined,  currentStage: undefined,  setCurrentStage: () => {},  testAnswers: [],  addAnswer: () => {},  editAnswer: () => {},  nextStage: () => {},  complete: () => {},  onTestStart: () => {},  stageStatuses: [],  setStageStatuses: () => {},  testingStarted: false,  stageComplete: {},  setStageQuestionsComplete: () => {},  testStartedDate: undefined,};const context = createContext<TPassContext>({  ...initialValues,});export const useTestPassContext = () => useContext(context) as TPassContext;export const TestPassContext: FC<PropsWithChildren> = ({ children }) => {  const { testId } = useParams<{    testId: string;  }>();  const [testLoaded, setTestLoaded] = useState<boolean>(    initialValues.testLoaded  );  const [testPending, setTestPending] = useState<boolean>(    initialValues.testPending  );  const [testLoadError, setTestLoadError] = useState<boolean>(    initialValues.testLoadError  );  const [currentStage, setCurrentStage] = useState<string | undefined>(    initialValues.currentStage  );  const [testingStarted, setTestingStarted] = useState<boolean>(    initialValues.testingStarted  );  const [stageStatuses, setStageStatuses] = useState<TStageStatus[]>([]);  const [test, setTest] = useState<TTesting | undefined>(initialValues.test);  const [testAnswers, setTestAnswers] = useState<TAnswer[]>(    initialValues.testAnswers  );  const [stageComplete, setStageComplete] = useState<    TPassContext['stageComplete']  >({});  const nextStage = useCallback(() => {    console.log('');  }, []);  const complete = useCallback(() => {    console.log('');  }, []);  const addAnswer = useCallback((answer: TAnswer | TAnswer[]) => {    const answersToAdd: TAnswer[] = Array.isArray(answer) ? answer : [answer];    setTestAnswers((prev) => [...prev, ...answersToAdd]);  }, []);  const editAnswer = useCallback((answer: TAnswer) => {    setTestAnswers((prev) =>      prev.map((el) => {        if (          el.questionId === answer.questionId &&          el.stageId === answer.stageId        ) {          return {            ...el,            ...answer,          };        }        return el;      })    );  }, []);  const fetchAnswer = useCallback(async (id: string) => {    setTestPending(true);    try {      const res = [];      setTestLoaded(true);    } catch (e) {      setTestPending(false);      setTestLoadError(true);    }  }, []);  useEffect(() => {    if (!testLoaded && !testPending && !testLoadError && testId) {      void fetchAnswer(testId);    } else if (      testId &&      test &&      test.id !== testId &&      !testPending &&      !testLoadError    ) {      void fetchAnswer(testId);    }  }, [testId, testLoaded, testPending, testLoadError, test]);  const handleStartTesting = useCallback(() => {    if (test && test.baseInfo.useStages) {      setCurrentStage(test.stages[0].id);    }    setTestingStarted(true);  }, [test]);  return (    <context.Provider      value={{        testLoaded,        testPending,        testLoadError,        test,        testIdToLoad: testId,        currentStage,        setCurrentStage,        nextStage,        complete,        testAnswers,        addAnswer,        editAnswer,        onTestStart: handleStartTesting,        stageStatuses,        setStageStatuses,        testingStarted,        stageComplete: stageComplete,        setStageQuestionsComplete: setStageComplete,      }}    >      {children}    </context.Provider>  );};